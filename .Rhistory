coefficients = c(beta0, beta))
)
}
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", val = "coeff_est", V2:V31)
library(tidyverse)
library(glmnet)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", val = "coeff_est", V2:V31)
tidy.cancer = tibble(cancer.CD$path) %>%
gather(., key = "covariate", val = "coeff_est", V2:V31)
tidy.cancer = as.tibble(cancer.CD$path) %>%
gather(., key = "covariate", val = "coeff_est", V2:V31)
View(cancer.CD$path)
tidy.cancer = as.tibble(cancer.CD$path) %>%
gather(., key = "covariate", val = "coeff_est", V3:V32)
LogLASSO.CD = function(X, y, beta, lambda, tol = 1e-5, maxiter = 10000) {
### Parameters: #####################################################
# X : design matrix                                                 #
# y : response variable (should be binary)                          #
# beta : starting beta coefficients to start from                   #
# lambda : constraining parameter for LASSO penalization            #
# tol : how precise should our convergence be                       #
# maxiter : how many iterations should be performed before stopping #
#####################################################################
# Turn the betas into their own matrix
X = as.matrix(X)
beta = as.matrix(beta)
n = length(y)
# Initialize important parameters before starting the coordinate descent
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Initialize the row for tracking each of these parameters
path = c(iter = 0, intercept = beta0, beta, log.lik = log.lik)
for (j in 1:maxiter) {
# Coordinate descent
for (k in 1:length(beta)) {
diff.y = (X %*% beta) - (X[,-k] %*% beta[-k])
threshold.prior = sum(omega * X[,k] * diff.y)
beta[k] = soft.threshold(threshold.prior,
gamma = lambda) / sum(omega * X[,k]^2)
}
# keep the old log-likelihood for convergence check
old.log.lik = log.lik
# With new betas, recalculate the working parameters
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Append it to tracking matrix
path = rbind(path,
c(iter = j, intercept = beta0, beta, log.lik = log.lik))
# Break the loop if the diff between likelihoods is below tolerance
if (abs(log.lik - old.log.lik) < tol) { break }
}
return(list(
path = as.tibble(path),
coefficients = c(beta0, beta))
)
}
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", val = "coeff_est", V3:V32)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", val = "coeff_est", V3:V31)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V3:V32)
colnames(cancer.CD$path)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "bottom") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
View(cancer.CD)
View(cancer.CD)
View(cancer.CD$path)
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.2
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.01
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.05
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
LogLASSO.CD = function(X, y, beta, lambda, tol = 1e-5, maxiter = 10000) {
### Parameters: #####################################################
# X : design matrix                                                 #
# y : response variable (should be binary)                          #
# beta : starting beta coefficients to start from                   #
# lambda : constraining parameter for LASSO penalization            #
# tol : how precise should our convergence be                       #
# maxiter : how many iterations should be performed before stopping #
#####################################################################
# Turn the betas into their own matrix
X = as.matrix(X)
beta = as.matrix(beta)
n = length(y)
# Initialize important parameters before starting the coordinate descent
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Initialize the row for tracking each of these parameters
path = c(iter = 0, intercept = beta0, beta, log.lik = log.lik)
for (j in 1:maxiter) {
old.beta = beta
# Coordinate descent
for (k in 1:length(beta)) {
diff.y = (X %*% beta) - (X[,-k] %*% beta[-k])
threshold.prior = sum(omega * X[,k] * diff.y)
beta[k] = soft.threshold(threshold.prior,
gamma = lambda) / sum(omega * X[,k]^2)
}
# keep the old log-likelihood for convergence check
old.log.lik = log.lik
old.beta0 = beta0
# With new betas, recalculate the working parameters
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Append it to tracking matrix
path = rbind(path,
c(iter = j, intercept = beta0, beta, log.lik = log.lik))
# Break the loop if the diff between likelihoods is below tolerance
if (
norm(rbind(beta0, beta) - rbind(old.beta0, old.beta), "F") < tol
) { break }
}
return(list(
path = as.tibble(path),
coefficients = c(beta0, beta))
)
}
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
LogLASSO.CD = function(X, y, beta, lambda, tol = 1e-5, maxiter = 10000) {
### Parameters: #####################################################
# X : design matrix                                                 #
# y : response variable (should be binary)                          #
# beta : starting beta coefficients to start from                   #
# lambda : constraining parameter for LASSO penalization            #
# tol : how precise should our convergence be                       #
# maxiter : how many iterations should be performed before stopping #
#####################################################################
# Turn the betas into their own matrix
X = as.matrix(X)
beta = as.matrix(beta)
n = length(y)
# Initialize important parameters before starting the coordinate descent
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Initialize the row for tracking each of these parameters
path = c(iter = 0, intercept = beta0, beta, log.lik = log.lik)
for (j in 1:maxiter) {
old.beta = beta
# Coordinate descent
for (k in 1:length(beta)) {
diff.y = (X %*% beta) - (X[,-k] %*% beta[-k])
threshold.prior = sum(omega * X[,k] * diff.y)
beta[k] = soft.threshold(threshold.prior,
gamma = lambda) / sum(omega * X[,k]^2)
}
# keep the old log-likelihood for convergence check
old.log.lik = log.lik
old.beta0 = beta0
# With new betas, recalculate the working parameters
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Append it to tracking matrix
path = rbind(path,
c(iter = j, intercept = beta0, beta, log.lik = log.lik))
# Break the loop if the diff between likelihoods is below tolerance
if (
norm(rbind(beta0, beta) - rbind(old.beta0, old.beta), "F") < tol
) { break }
}
return(list(
path = as.tibble(path),
coefficients = c(beta0, beta))
)
}
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
View(cancer.CD$path)
LogLASSO.CD = function(X, y, beta, lambda, tol = 1e-5, maxiter = 1000) {
### Parameters: #####################################################
# X : design matrix                                                 #
# y : response variable (should be binary)                          #
# beta : starting beta coefficients to start from                   #
# lambda : constraining parameter for LASSO penalization            #
# tol : how precise should our convergence be                       #
# maxiter : how many iterations should be performed before stopping #
#####################################################################
# Turn the betas into their own matrix
X = as.matrix(X)
beta = as.matrix(beta)
n = length(y)
# Initialize important parameters before starting the coordinate descent
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Initialize the row for tracking each of these parameters
path = c(iter = 0, intercept = beta0, beta, log.lik = log.lik)
for (j in 1:maxiter) {
old.beta = beta
# Coordinate descent
for (k in 1:length(beta)) {
diff.y = (X %*% beta) - (X[,-k] %*% beta[-k])
threshold.prior = sum(omega * X[,k] * diff.y)
beta[k] = soft.threshold(threshold.prior,
gamma = lambda) / sum(omega * X[,k]^2)
}
# keep the old log-likelihood for convergence check
old.log.lik = log.lik
old.beta0 = beta0
# With new betas, recalculate the working parameters
beta0 = sum(y - X %*% beta) / n
p = calc.cur.p(intercept = beta0, data = X, betas = beta)
z = calc.working.resp(intercept = beta0, data = X, resp = y,
betas = beta, p = p)
omega = calc.working.weights(p)
log.lik = calc.log.lik(data = X, weights = omega, w.resp = z,
intercept = beta0, betas = beta, lambda = lambda)
# Append it to tracking matrix
path = rbind(path,
c(iter = j, intercept = beta0, beta, log.lik = log.lik))
# Break the loop if the diff between likelihoods is below tolerance
if (
norm(rbind(beta0, beta) - rbind(old.beta0, old.beta), "F") < tol
) { break }
}
return(list(
path = as.tibble(path),
coefficients = c(beta0, beta))
)
}
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = lm(diagnosis ~ ., data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
tidy.cancer = cancer.CD$path %>%
gather(., key = "covariate", value = "coeff_est", V1:V30)
ggplot(data = tidy.cancer, aes(x = iter, y = coeff_est,
color = covariate, group = covariate)) +
geom_line() +
theme(legend.position = "none") +
labs(
title = "Log-LASSO coefficient estimates through iteration",
x = "Iteration Cycle",
y = "Coefficient Estimate"
)
lambda0 = max(coeffs)
lambda0 = max(coeffs)
lambda.seq = seq(1e-4, lambda0. length.out = 1000)
lambda0 = max(coeffs)
lambda.seq = seq(from = 1e-4, to = lambda0, length.out = 1000)
lambda0 = max(coeffs)
lambda.seq = seq(from = 1e-4, to = lambda0, length.out = 1000)
coeff.path = NULL
for (l in 1:length(lambda.seq)) {
fit = cancer.CD(X = X, y = y, beta = coeffs, lambda = lambda.seq[l])
coeff.path = rbind(coeff.path,
lambda = lambda.seq[l],
fit$coefficients)
}
lambda0 = max(coeffs)
lambda.seq = seq(from = 1e-4, to = lambda0, length.out = 1000)
coeff.path = NULL
for (l in 1:length(lambda.seq)) {
fit = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda.seq[l])
coeff.path = rbind(coeff.path,
lambda = lambda.seq[l],
fit$coefficients)
}
lambda0 = max(coeffs)
lambda.seq = seq(from = 1e-4, to = lambda0, length.out = 100)
coeff.path = NULL
for (l in 1:length(lambda.seq)) {
fit = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda.seq[l])
coeff.path = rbind(coeff.path,
lambda = lambda.seq[l],
fit$coefficients)
}
View(coeff.path)
lambda0 = max(coeffs)
lambda.seq = seq(from = 1e-4, to = lambda0, length.out = 100)
coeff.path = NULL
for (l in 1:length(lambda.seq)) {
fit = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda.seq[l])
coeff.path = rbind(coeff.path,
c(lambda = lambda.seq[l],
fit$coefficients))
print(paste("Iter", l, "done", sep = " "))
}
View(coeff.path)
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V2:V32)
View(coeff.path)
colnames(coeff.path)
View(coeff.path)
rep(paste("X",), 31)
rep(paste("X"), 31)
paste("X", 1:31)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = tidy.lambda, aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line()
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line()
X = data %>% select(radius_mean:fractal_dimension_worst) %>% as.matrix(.)
y = data$diagnosis
# initial guess will be what is produced by regular linear regression
beta = glm(diagnosis ~ ., family = binomial(link = "logit"), data = data)
coeffs = as.matrix(beta$coefficients[2:length(beta$coefficients)])
lambda = 0.1
cancer.CD = LogLASSO.CD(X = X, y = y, beta = coeffs, lambda = lambda)
View(coeffs)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line()
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line() +
xlim(-0.25, 0.25)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line() +
ylim(-0.25, 0.25)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line() +
ylim(-0.2, 0.2)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.125), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line() +
ylim(-0.2, 0.2) +
xlim(0, 0.02)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.1), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line() +
ylim(-0.2, 0.2) +
xlim(0, 0.02)
colnames(coeff.path) = c("lambda", paste("V", 1:31, sep = ""))
tidy.lambda = as.tibble(coeff.path) %>%
gather(., key = "coeff", value = "coeff_est", V1:V31)
ggplot(data = subset(tidy.lambda, lambda < 0.1), aes(x = lambda, y = coeff_est,
color = coeff, group = coeff)) +
geom_line()
